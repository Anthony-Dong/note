# 单例模式

## 1. 饿汉式  (在类装载的时候完成实例化)

```java
public class Singleton01 {

    private  static final Singleton01 singleton ;

    static{
        
    当类加载器加载的时候直接加载       
        singleton = new Singleton01();
    }

    private Singleton01(){}

    public  static Singleton01 getSingleton(){
        return singleton;
    }


    public static void main(String[] args) {
        Singleton01 singleton = Singleton01.getSingleton();
        Singleton01 singleton1 = Singleton01.getSingleton();

        System.out.println(singleton == singleton1);
    }
}

```



## 2. 懒汉式 (需要的时候才要加载)

- 最简单的方式 就是 静态内部类

```java
public class Singleton {
    //3.构造方法私有化
    private Singleton(){}

    // 1.写一个静态内部类
    private static class SingletonInstance{
        private static final Singleton singleton = new Singleton();
    }
    // 2.实现加载
    public static Singleton getInstance(){
        return SingletonInstance.singleton;
    }
}
```

- 双重检查 ,进行同步

```java
public class DoubleCheckSingleton {

    // 保证可见性
    private static volatile DoubleCheckSingleton instance;

    private DoubleCheckSingleton(){

    }

    public static DoubleCheckSingleton getInstance(){
		// 检测 1
        if (null == instance) {
            synchronized (DoubleCheckSingleton.class) {
                // 检测 2
                if (null == instance) {
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
```





## 3. 那我们怎么给他传递参数呢,我们都是直接实例化了

很简单 就是调用get  set 方法 ,因为对象只是一个地址引用,成员变量地址

```java
class Singleton {
    //3.构造方法私有化
    private Singleton(){}


    private String name;

    private Date date;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    // 1.写一个静态内部类
    private static class SingletonInstance{
        private static final Singleton singleton = new Singleton();
    }

    // 2.实现加载
    public static Singleton getInstance(String name, Date date) {
        Singleton singleton = SingletonInstance.singleton;

        singleton.setDate(date);

        singleton.setName(name);
        return singleton;
    }

}

```

我们写一个测试类 测试一下并发请求 到底是不是

```java
    @RequestMapping("/get7")
    public @ResponseBody Singleton get7(){

        Singleton instance = Singleton.getInstance(new SecureRandom().nextInt(1000) + "", new Date());
        System.out.println("hashcode 值:" + instance.hashCode() +" name: "+instance.getName().hashCode()+" date : "+instance.getDate().hashCode());
        return instance;
    }

```

![](https://tyut.oss-cn-beijing.aliyuncs.com/image/2019-09-21/07bda822-3915-4c83-afc9-fd0dd0dcd74b.jpg?x-oss-process=style/template01)



结果很显然是对的, 

> ​	但是这种方式存在一种问题 :  很严重的问题 ,  由于我们的单例对象是一个静态变量的方式存在, 因此他在 jvm 的整个生命周期中都存在, jvm 不会去回收 , 造成严重的浪费内存行为 





## 4. 对比使用单例模式 和 普通模式内存差异

 很显然 单例模式 占用内存小,但是需要注意 的 是我上面的哪一点 ,

普通的创建对象 ,jvm 会自动回收 ,这种方式也很好 