# JVM垃圾回收算法

> ​	本篇并不会讲怎么样才会被回收,怎么对象才算死亡 , 怎样才算引用 , 只是讲了一些常用算法的算法流程和常用收集器。

## 1. 引用计数法 (Reference Counting)

​		引用计数法是最经典的垃圾回收算法, 他的实现很简单 ,举个栗子 : 一个对象 A ,假设他被任意一个对象引用 ,那么A的引用计数器就会加1 ,  当引用失效的时候 ,引用计数器就会减1 ,当为0的时候 对象A就会被回收 .

​		但是他存在几个比较严重的问题 : 

​		1、无法处理循环引用 ,例如A引用B ,B引用A , 但是此时并没有其他对象应用A和B ,那么AB 一直存在 ,会造成内存泄漏

​		2、他对于每次对象的销毁,生成都会进行运算 , 占用计算机CPU性能 .



## 2. 标记清除法 (Mark-Sweep)

​		**标记清除法是现代垃圾回收算法的思想**, 它主要**将GC分为了两个阶段** : 标记阶段 , 清除阶段 . 在标记阶段,首先通过根节点 ,标记所有的可达对象(就是通过跟对象进行引用搜索可以到达的对象) , 此时未被标记的对象就会被清除 . 

​		这个算法存在的最大的问题就是造成大量的空间碎片, 所以不适用于小内存的情况 .  

### 1. 并发标记清除法 CMS(Concurrent Mark-Sweep)

​		这是网上的文章 , [链接](https://blog.csdn.net/wfh6732/article/details/57490195) : https://blog.csdn.net/wfh6732/article/details/57490195

​		这种算法主要的适用场景就是 : 如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是**硬件牛逼**)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(**老年代**比较大)会更适合使用CMS。

## 3. 复制算法 (Copying)

​		复制算法的第一个阶段类似与标记清除法 , 第二阶段是将存活的对象复制到一个未使用的内存块中 ,然后清空原来的内存空间 ,此时就不会造成大量的碎片空间 . 

​		**在JVM的新生代串行垃圾回收器中 , 就使用的是复制算法的思想** , 新生代分为了 eden空间 , from 空间 , to空间 三个部分 , 其中 : from 空间和to空间 称为 survivor 空间 ,他俩主要是用来存放未被回收的对象,可以看做一个地位相同的空间,可以进行角色互换. **为什么需要两块survivor呢 ,因为需要迭代 , 一块没法迭代 ,了解流程就可以理解了** . 

​		**我将一下大致流程** : 在第一次GC开始的时候 , eden空间 所有存活的对象都被 copy到了 survivor 的一块空间(To空间) , 然后此时清空eden 空间和另一块survivor空间(From) , 此时 第一次GC 结束  . 第二次GC开始的时候 To 和 From交换角色 . 此时 From 空间有对象 , 由于第二次GC , 此时 eden 区域产生存活下来的对象 , From 也会有存活下来的对象 , 那么 就会将 From 空间存活下来的对象和eden空间存活下来的对象 全部 copy到 To区域 . 循环往复 ,当一块survivor 区域满了的时候就会全部移动到老年带 . 

​		如果存在特别大的对象 , 会直接放入老年代的 .  还有迭代次数是可以设置的 	

​		希望我上面的描述大家可以理解 ,说实话好多书都是互相抄的感觉没有将很明白 .  我画了张流程图希望大家可以理解 : 

![](https://tyut.oss-cn-beijing.aliyuncs.com/image/2019-11-03/cbd9f8cd-3fa5-4f4a-93d3-b67f7acf802c.jpg?x-oss-process=style/template01)

  

## 4. 标记压缩法 (MarkSweepCompact)

​		上面讲到的复制算法的高效性建立在存活对象比较少,垃圾对象多的前提下, 这样情况在新生代经常发生 , 但是再老年代 , 更常见的情况是大部分都是存活对象 . 如果我们依旧使用复制算法 ,由于对象较多,复制的成本会很高 .因为基于老年代的特征, 我们需要使用其他算法 .

​		标记压缩法 , 和标记清除法很相似 , 他在后者的基础上做了一些优化 . 第一阶段和标记清除法一样 , 都是从根对象开始遍历 , 找出可达对象做标记 . 但是它并不只是简单的清理未标记的对象. 而是将所有的存活对象压缩到内存的一端 . 之后再清理全部未标记的对象. 这种算法和复制算法也相似,只是一个复制一个是移动. 都可以解决空间碎片的问题 . 

## 5. 分代算法 (Generational Collection)

​		分代算法不能称之为一种算法 ,而是因地制宜 , 因区而议 , 比如新生代用复制算法, 老年代使用标记压缩法 . 

​		其中里面讲述了新生代和老年代一种关联关系 , 为了支持更高效的新生代的回收 , 不可能采用简单的逻辑去判断, 而是采用了一种被称之为 卡表 (Card Table) 的数据结构 . 卡表的单位比特位 , 每一个比特位表示老年代中某一个区域的所有对象是否持有新生代的引用 . 这样在新生代GC时候, 就不需要花费大量的时间扫描所有的老年对象 ,来确定每一个对象的引用关系 ,它可以先扫描卡表 , 只有当卡表被标记为1时 , 才需要扫描指定区域的老年对象 , 而卡表为0的地方 ,一定不存在引用 . 

​		下面这张图展示了卡表的引用关系 ,只有计数器为1 的才去指向新生代.  

![](https://tyut.oss-cn-beijing.aliyuncs.com/image/2019-11-03/00a24ef2-1161-465f-853f-974212e8a2a5.png?x-oss-process=style/template01)	



## 6. 分区算法(Region)

​		分区算法是将一个对象的生命周期长短划分为两个部分, 从而将整个空间划分为连续不同的小区间 , 每一个区间都是独立使用的 ,独立回收 . 

​		由于GC回收的时候讲整个堆空间锁住 , 不允许其他操作, 此时就会造成过多的问题, 分区只需要根据区的情况进行回收 .  不用涉及到整个堆空间. 

​		所以往一个大的方向走 ,就是分区 ,小的地方走就是分代 , 侧重点不同而已 . 



## 7. 收集器及配置参数 

### 1. 串行（Serial）收集器 

> ​	 1、使用单线程处理所有垃圾回收工作，因为无需多线程交互，所以效率比较高。但是，也无法使用多处理器的优势，所以此收集器适合单处理器机器。
>
> ​	2、可以使用`-XX:+UseSerialGC` 打开。
>
> ​	3、适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。
>
> ​	4、缺点：只能用于小型应用.



### 2. 并行（Parallel）收集器

> ​	 1、对年轻代进行并行垃圾回收，因此可以减少垃圾回收时间。一般在多线程多处理器机器上使用。使用`-XX:+UseParallelGC`打开。
>
>  	2、使用`-XX:ParallelGCThreads=<N> `设置并行垃圾回收的线程数。此值可以设置与机器处理器数量相等。
>
> ​	 3、吞吐量 :  吞吐量为垃圾回收时间与非垃圾回收时间的比值 ，通过`-XX:GCTimeRatio=<N> `来设定，公式为1/（1+N） ,例如，-XX:GCTimeRatio=19时，表示5%的时间用于垃圾回收。默认情况为99，即1%的时间用于垃圾回收。
>
> ​	 4、最大垃圾回收暂停: 指定垃圾回收时的最长暂停时间，通过`-XX:MaxGCPauseMillis=<N> `指定。<N>为毫秒.如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量。
>
>  	5、适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算
> 	 6、缺点：应用响应时间可能较长





### 3. 并发收集器 - 并发标记清除（Concurrent Mark Sweep）

> ​	关于**并发标记清除**的讲解上面提到过了 ,这里直接讲解参数
>
> ​	1、 启用CMS：`-XX:+UseConcMarkSweepGC `
>
> ​	2 、开启碎片整理:    `-XX:+UseCMSCompactAtFullCollection`
>
> ​	3 、回收的线程数:    `-XX:ParallelCMSThreads=<N>`
>
> ​	4 、回收触发的阈值(单位 百分号):     `-XX:CMSInitiatingOccupancyFraction=<N>`
>
> ​	5 、适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。
>
> ​	6 、缺点 : 需要很高的硬件设施

