# 为什么说函数只存在值传递

## 1. 例子一

我们先来几个例子. 先来Java的吧. Java最假了. 一般人都认为是引用传递(基本类型值传递).  所以我们又拿C++做例子. 

写 a , b 是为了好区分开.  其实 写俩a都行. 不好书面表达

```java
public class Demo {

    public static void main(String[] args) {
        A a = new A();
        System.out.println("初始化 : " + a.name);
        a.name = "main";
        System.out.println("init函数调用前 : " + a.name);
        // change 函数传递
        init(a);
        // 结果 ?
        System.out.println("init函数调用后 : "+a.name);
    }

    static void init(A b) {
        // a被初始化了..
        b = new A();
    }

    private static class A {
        String name;
    }
}
```

输出 : 

```java
初始化 : null
init函数调用前 : main
init函数调用后 : main
```

结果是啥. 如果真的是引用传递. 那么为啥a.name为啥不是空呢. 

我用C++ 给大家写一下. 

 ```c++
#include <iostream>
#include <string>

using namespace std;

class A
{
public:
    string name;
};

void init(A *b)
{
    cout << "未改变的地址 : " << b << endl;
    *b = A();
    cout << "改变后的地址 : " << b << endl;
}
int main(int argc, char const *argv[])
{
    A *a = new A();
    cout << "初始化 : " << a->name << endl;
    a->name = "main";
    cout << "init函数调用前 : " << a->name << endl;
    init(a);
    cout << "init函数调用后 : " << a->name << endl;
    return 0;
}
 ```

输出 

```java
初始化 : 
init函数调用前 : main
未改变的地址 : 0xe699d0
改变后的地址 : 0xe699d0
init函数调用后 : 
```

显然C++和Java的表现是不一样的.  为什么C++ 赋值可以改变值. 而Java却不是呢. 

**我们先解释C++的做法.** 

我们 `init(A *b) `做了啥

首先是我们定义了一个变量 A *a=new A("main") , 我没有写构造函数, 假设的.   

此时传递给函数`init(A *b)`  , 此时 b=a  ,a= 0xe699d0 . 所以呢 b= 0xe699d0 . 

后面我们的操作就是基于 b 的. 此时我们将 ` *b = A(); `  ,   是不是将 `0xe699d0指针`指向了  `A()` 对象呢(其实就是块内存,指向的是内存的首地址)  . 此时是不是修改了 `0xe699d0指针` 的指向呢.  那么a也等于 0xe699d0 .所以a的值也被修改了 . 



**然后我们看看Java的做法.** 

```java
static void init(A b) {
    System.out.println("未改变的地址: 0x"+Integer.toHexString(a.hashCode()));
    // a被初始化了..
    b = new A();
    System.out.println("改变后的地址: 0x"+Integer.toHexString(a.hashCode()));
}
```

我们打印一下  hashcode. 因为Java的hashcode其实就是内存地址(然后16进制转成了10进制了).  输出结果: 

```java
初始化 : null
init函数调用前 : main
未改变的地址: 0x6e8cf4c6
改变后的地址: 0x12edcd21
init函数调用后 : main
```

此时我们发现地址发生了改变.  其实理解了上面C++那部分聪明的就明白了. 

由于Java引用类型传递是值针传递.  

由于一开始 a=0x6e8cf4c6(Java引用对象,其实默认指针类型) , 然后函数赋值 b=a , 此时 b= 0x6e8cf4c6. 

但是差别就是在于 Java不能直接基于内存操作 . 也就是不能直接修改指针引用的数据 .  也就是没有取值符号. 

所以new A(); 执行的是. 实例化一个A对象. 将A对象保存在临时变量z中,此时z=0x12edcd21, 然后将b=z. 此时b=0x12edcd21 . 那么改变原来0x6e8cf4c6指向的内容了吗.  并没有. 



## 2. 例子二

> ​	其实你理解上面这个例子. 你就明白了为啥值传递了.  我们继续拿C++说话. Java查看地址不方便. 



```c++
#include <iostream>

using namespace std;

void swap(int *a, int *b)
{
    int *temp = a;
    a = b;
    b = temp;
    cout << "a : " << *a << " , b : " << *b << endl;
}

int main(int argc, char const *argv[])
{
    int x = 1;
    int y = 2;

    cout << "x : " << x << " , y : " << y << endl;
    // swap 方法.
    swap(&x, &y);

    cout << "x : " << x << " , y : " << y << endl;
    /* code */
    return 0;
}
```

输出 

```c++
x : 1 , y : 2
a : 2 , b : 1
x : 1 , y : 2
```

我们发现为啥函数内部 . a 和 b 成功交换了地址 . 所以 a 和 b的值就互换了 . 

但是为啥呢. 

我们再次打印一下地址 

```c++
cout << "&x  : " << &x << " , &y : " << &y << endl;
// 输出 : 
&x : 0x61fefc , &y : 0x61fef8
```

&x = 0x61fefc ,  &y=0x61fef8 , 

执行swap函数.  此时 a=0x61fefc ,  b=0x61fef8  , 

然后经过一番操作, 此时 a=0x61fef8    ,  b=0x61fefc  . 然后输出 *a=2, *b=1,  所以成功了. 

但是为啥  x 和 y 没变呢. 是不是发现 &x 和 &y依旧着原来的地址呢.   



正确的swap操作 , 必须修改指针指向的值. 

```c++
void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
```



