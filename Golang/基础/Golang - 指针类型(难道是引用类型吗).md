# Golang - 指针 

 	 Golang有指针(这里指针不完全等价于C语言的指针) , 但是有些人生下来就是指针类型哇 , 跟Java的对象一样, 天生他就是一个指针类型(可以理解为引用类型,类似于Java的引用.).  但是Golang有些人不是哇, 他生下来不是指针类型.  好多人对于引用类型和指针类型分不清, 什么对象需要加`&`和`*` ,  请看我下面这段话. 



​	**关于引用类型的实现 : **

- 第一种就是句柄访问(类似于一种映射关系),通过访问句柄指针来操作原数据  ,
- 第二种就是直接指针类型. 直接就是指向原数据的地址的指针类型.   所以引用类型==指针类型 , 这个看情况 . 所以你拿到只是一个壳子. 要么你就去造壳子去吧. 



当你阅读完上诉两段话, 我觉得你并不会纠结什么是引用类型和什么是指针类型了. 因为实现方式不同罢了. 

### 小技巧

**记住用伟大的Jetbrains的编译器Goland, 可以提示代码错误奥 !** 

```go
package main

import "fmt"

func main() {
	// 生下来一个ch
	ch := make(chan int)
	
	// ch如果是指针类型就可以和nil比较了,或者直接打印也可以
	fmt.Println(ch==nil)
}
```

​	**就上诉一段代码 , 让你明白啥对象生下来我就是指针类型(引用类型).  啥对象生下来他不是指针类型 , 如果你掌握了,我觉得那些书你不用看了.**



> ​	**对于Golang也是一种内存管理的一种编程语言, 他编程方式和C++和C很相似, 但是思想上和Java却很相似. 所以你拿到的对象并不是一个C定义的struct  , 而是另一层封装. 因为Golang帮助我们管理内存了,他需要分配内存和回收呢 **



> ​	**我给大家列出来 , 哪些对象哇 , 他生下来就是指针类型.  都是靠我上面的小技巧获取的,还有自己的一些经验. 所有这些都需要多练习, 多补充.** 

### 生下来就是指针类型 (引用类型)

- chan , 是一个阻塞队列,你可以这么理解, 后期学习吧, 类似于Java的BlockingQueue .

- map , 伟大的map , 其实就是Java的HashMap.(所以不安全)

- 切片(slice)  , 就是没有指定长度的数组 ,类似于Java的ArrayList,会自动扩容.

- 函数 , 比如 `fun := func(s string) string { return "modify" + s }`

- **interface** :  **一个类型为`interface{} 或者 interface接口` 的变量可能是指针变量 , 也可能是普通变量 .**  

  ```go
  // 定义一个接口
  type UserService interface {
  }
  // str可以是指针类型变量也可以是普通变量 , fun5也是
  func fun4(str interface{}) {
  }
  func fun5(str UserService) {
  }
  
  func main() {
  	// u 代表是一个指针类型变量或一个普通变量 ,同理 var x interface{} 也是代表一个指针类型变量或一个普通变量
  	var u UserService
  	// 调用
  	fun4(u)
  	fun5(u)
  }
  ```

- function type.  比如 `type Func func(string)` , 这个 Func 就是一个function type.  还有func类型也是. 

  ```go
  type Func func(string)
  func main() {
  	fun := Func(func(s string) {})
  	fmt.Println(fun == nil) // false
  }
  ```

### 生下来是值类型的

- struct , 如果成员变量为基本数据类型就是初始化值, 如果成员变量的指针类型则是nil.(前提你不赋值的情况下)

- 基本数据类型,初始化值如下

  ```go
  bool //默认值为false
  string //默认值为空字符串,为""
  int int8 int16 int32 int64 //默认值为0
  uint uint8 uint16 uint32 uint64 uintptr //默认值为0
  byte // uint8 的别名
  rune // int32 的别名
  float32 float64 //默认值为0
  complex64 complex128 //默认值为0
  ```

- 数组 , 数组是初始化就定义了大小的  , 记得与切片区分开. 


### 两大操作符

操作符&(取址符) : 是返回该变量的内存地址。
操作符* (取值符) : 是返回该指针指向的变量的值, 同时也可以进行修改指针指向内存地址的值.

### 空指针

当一个指针类型的变量被定义后没有分配到任何变量时，它的值为 nil。空指针问题会有很多, 注意平时使用点.
nil 指针也称为空指针。
nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值.

### 占位符

```go
%d										十进制整数
%x,	%o,	%b								十六进制，八进制，二进制整数。
%f,	%g,	%e								浮点数：	3.141593	3.141592653589793	3.141593e+00 
%t										布尔：true或false 
%c										字符（rune）	(Unicode码点) 
%s										字符串 
%q										带双引号的字符串"abc"或带单引号的字符'c'
%v										变量的自然形式（natural	format） 
%T										变量的类型 
%%										字面上的百分号标志（无操作数）
%p										打印指针类型的地址(十六进制)
```



### Golang 的全部类型 

> ​	这个是官方给的类型, 只有两种 一种是数值类型一种是派生类型.

**数值类型**

- 布尔型

  `bool` 布尔型的值只可以是常量 `true` 或者 `false`，默认值为 `false`。

- 字符串类型

  `string` 编码统一为 `UTF-8` 编码标识 `Unicode` 文本，默认值为空字符串。

- 整型（默认值为 0）

  - `uint8`： 无符号 8 位整型（0 ~ 255）；
  - `uint16`：无符号 16 位整型（0 ~ 65535）；
  - `uint32`：无符号 32 位整型（0 ~ 4294967295）；
  - `uint64`：无符号 64 位整型（0 ~ 18446744073709551615）；
  - `int8`：有符号 8 位整型（-128 ~ 127）；
  - `int16`：有符号 16 位整型（-32768 ~ 32767）；
  - `int32`：有符号 32 位整型（-2147483648 ~ 2147483647）；
  - `int64`：有符号 64 位整型（-9223372036854775808 ~ 9223372036854775807）

- 浮点型（默认值为 0）

  - `float32`：`IEEE-754` 32 位浮点数；
  - `float64`：`IEEE-754` 64 位浮点数；
  - `complex64`：32 位实数和虚数；
  - `complex128`：64 位实数和虚数；

- 其他数值类型

  - `byte`：类似 `uint8`；
  - `rune`：类似 `int32`；
  - `uint`：32 或 64 位；
  - `int`：与 `uint` 一样大小；
  - `uintptr`：无符号整型，用于存放一个指针；

**派生类型**

- 指针类型（Pointer）
- 数组类型 ([len]byte)
- 结构化类型（struct）
- Channel 类型（chan）
- 函数类型（func）
- 切片类型（slice）
- 接口类型（interface）
- Map 类型（map）



