# 监听者模式

> ​	何为监听者模式 ? 
>
> ​	我认为你要是认真看源码 ,认真做开发 ,绝对见到 一堆后缀是 `Listener`的类, 那你还不赶紧学习 ,别老想着用别人的 ,自己也要动脑子 , 那么你要是有兴趣就看看我写的吧 ,涉及的很全 , 我是从全局观进行讲解, 设计到的多线程知识, 我前面的文章有讲解 , 希望不了解的可以看看我的文章 . 同时还介绍了 Spring中的事件监听我们如何去使用 , 希望对你的开发有帮助 . 



## 1. Java原生规范

### 1. EventObject

> ​	**事件对象 , 他需要一个事件源 , 用构造函数传递的**

```java
public class EventObject implements java.io.Serializable {
    protected transient Object  source;

    public EventObject(Object source) {
        if (source == null)
            throw new IllegalArgumentException("null source");

        this.source = source;
    }
    ........... 其他省略 
}
```

### 2. EventListener

> ​	**事件监听者,他是负责监听事件的 , JAVA提供的是一个空接口, 让我们根绝需求写** 

```java
public interface EventListener {
}
```

### 3. 总结

我们发现 java 提供的只提供了一个事件对象 ,和一个事件监听器  ,所以需要我们遵守这个规范去开发



## 2. 基于Java接口设计一个监听者模式

### 1. 事件源 - EventSource 

一般情况下 都会设置成一个 Object 类型的 , 不需要我们去设计一个,为了体现设计模式的角色,我们就设计了一个

```java
@ToString
@Setter
@Getter
public class EventSource {
    private String name;
    private String info;
}
```

### 2. 事件对象 - EventObject

这里我们继承了 EventObject , 只是简单的实现了一下 , 并没有做过多的包装

```java
public class CoreEventObject extends EventObject {
    public CoreEventObject(EventSource source) {
        super(source);
    }
}
```

### 3. 事件监听者 - EventListener

这里我们真正的监听者 , 一般情况下都需要设计成一个 函数式接口 , 我这个是和Spring框架学习的 , 因为函数式接口才能体现回调 , 

```java
@FunctionalInterface
public interface CoreEventListener<E extends CoreEventObject> extends EventListener {

    void onEventObject(E event);
}
```

### 4. 事件发布者 -  EventPublisher

事件发布者 ,因为没有发布的事件对象, 哪来的监听 

```java
public class EventPublisher<E extends CoreEventObject> {

    private CoreEventListener<E> listener;


    public EventPublisher(CoreEventListener<E> listener) {
        this.listener = listener;
    }

    
    public void publish(E object){
        System.out.println("发布事件 : " + object);
        // 传给 CoreEventListener
        listener.onEventObject(object);
    }
}
```

### 5. 测试Demo

```java
public class TestDemo {
    public static void main(String[] args) {
        // 1. 创建一个事件发布者
        EventPublisher<CoreEventObject> publisher = new EventPublisher<>(new CoreEventListener<CoreEventObject>() {
            @Override
            public void onEventObject(CoreEventObject event) {
                System.out.println("接收到事件源 : " + event.getSource() + " , 当前线程 : " + Thread.currentThread().getName()); 
            }
        });

        // 2. 发布一个事件对象 
        publisher.publish(getCoreEventObject());
    }

    private static CoreEventObject getCoreEventObject(){
        ..... 此处省略 
        return eventObject;
    }
}
```

输出结果 : 

```java
发布事件 : com.example.listener_design_pattern.CoreEventObject[source=EventSource(name=事件源, info=Sat Nov 09 14:34:50 CST 2019)]
接收到事件源 : EventSource(name=事件源, info=Sat Nov 09 14:34:50 CST 2019) , 当前线程 : main
```

我们发现我们成功的接收到了事件对象 和 事件源 , 这个就是钩子函数的魅力 . 其实你只是做了一个事件发布你无心观察其他的东西 , 只需要一个监听者就可以做到监听了 , 这样你的事件发布 和 监听 完全就解耦了 .其实底层就是一个地址引用 . 

## 3. 不用回调函数的监听者模式

### 1. 我们的问题 ? 

很多场景下,我们的发布事件和监听事件完全在两个线程中,那么我们如何拿到事件对象呢 ?  

如果我们简单使用一下 , 会这么写 ? 

```java
public class TestEventListener implements CoreEventListener<CoreEventObject> {

    private CoreEventObject object;

    @Override
    public void onEventObject(CoreEventObject object) {
 		// 赋值给成员变量 
        this.object = object;
    }

    // 获取成员变量 
    public CoreEventObject getObject() {
        return object;
    }
}
```

测试一下 : 

```java
public class TestDemo {

    public static void main(String[] args) {

        TestEventListener listener = new TestEventListener();
        CoreEventObject object = listener.getObject();
        // 先去拿 ,后去发布
        System.out.println(object.getSource());

        EventPublisher<CoreEventObject> publisher = new EventPublisher<>(listener);
        publisher.publish(getCoreEventObject());
    }


    private static CoreEventObject getCoreEventObject(){
			.... 
        return eventObject;
    }

}

```

输出结果

```java
Exception in thread "main" java.lang.NullPointerException
	at com.example.listener_design_pattern.TestDemo.main(TestDemo.java:28)
```

有些人就会说 , 你这不对哇 ,你当然拿不到了 ,因为人家还没发布了 ,但是在多线程 ,在解耦的情况下 ,你哪知道对面何时发布结束了 , 你再去拿呢 ? 那就需要java的多线程知识了 ,Future 给我们带来了提醒 , 就是阻塞的思想 , 只有监听者真正的收到对象 , 我们才能去拿 . 

### 2. 解决问题 

了解过我前面提到的那一节 `FutureTask`是如何实现的 ,我觉得问题就迎刃而解了 . 

```java
public class TestEventListener implements CoreEventListener<CoreEventObject> {
    private CoreEventObject object;

    /**
     * 当 X = 0 ,代表 obj还没有初始化了
     * 当 x = 1 , 代表 obj 以及初始化了 , 已经接收到了
     */
    private static volatile int x = 0;

    @Override
    public void onEventObject(CoreEventObject object) {
        this.object = object;
        // 收到改成 1
        x = 1;
    }

    public CoreEventObject getObject() {
        while (true) {
            if (x == 1) {
                break;
            }
        }
        // 拿到对象,再设置为1
        x = 0;
        return object;
    }
}
```

由于这个解决方案,会使得执行`getObject()` 的线程一直的阻塞下去,就是死循环下去,我们必须一个线程去执行这个方法 , 

```java
public class TestDemo {
    public static void main(String[] args) {
        TestEventListener listener = new TestEventListener();
        // 新建一个线程去接收
        Thread thread = new Thread(() -> {
            System.out.println("我开始接收对象 : " + System.currentTimeMillis());
            CoreEventObject object = listener.getObject();
            System.out.println("成功接收对象 : "+object.getSource());
        });
        thread.start();
		// 新建一个线程去发布
        EventPublisher<CoreEventObject> publisher = new EventPublisher<>(listener);
        new Thread(()->{
            publisher.publish(getCoreEventObject());
        }).start();
    }


    private static CoreEventObject getCoreEventObject(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        EventSource source = new EventSource();
        source.setName("事件源");
        source.setInfo("" + System.currentTimeMillis());
        return new CoreEventObject(source);
    }
}
```

输出结果 : 

```java
我开始接收对象 : 1573282924555
发布事件 : com.example.listener_design_pattern.CoreEventObject[source=EventSource(name=事件源, info=1573282925590)]
成功接收对象 : EventSource(name=事件源, info=1573282925590)
```

我们我们接收的时候是在1573282924555的时间搓 , 而真正拿到的对象确实在1573282925590发布的 , 这个就完全在俩时间轴上,所以我们成功的解决了问题 . 

## 4. Spring中的Listener使用

### 1. ApplicationEvent

> ​	Class to be extended by all application events. Abstract as it doesn't make sense for generic events to be published directly.
>
> ​	此类被所有的 `application events` 所继承 。抽象的原因是因为直接发布这个`ApplicationEvent`是没有意义的。

### 2. ApplicationListener

> ​	Interface to be implemented by application event listeners. Based on the standard java.util.EventListener interface for the Observer design pattern.
>
> ​	这个接口被所有的 ` application event listeners.`所实现 , 基于Java的 ` java.util.EventListener`接口规范

### 3. 开始使用

我们有一个需求就是 ,我们有一个服务会从远程不断的去拉去配置信息 ,一旦有改变就会发布配置信息 .

#### 1. Config - 事件源

```java
@ToString
@Setter
@Getter
public class Config {
    private String namespace;
    private Map<String, Object> info;
}
```

#### 2. ConfigEvent - 事件对象

```java
// 这个注解,我们是根据Spring源码看到的 , 所以一致性,我就加了
@SuppressWarnings("serial")
public class ConfigEvent extends ApplicationEvent {

    public ConfigEvent(Config source) {
        super(source);
    }
}
```

#### 3. ConfigEventListener - 事件监听者

```java
@Component
public class ConfigEventListener implements ApplicationListener<ConfigEvent> , Ordered, InitializingBean {

    @Override
    public void onApplicationEvent(ConfigEvent event) {
        System.out.println("接收到更新信息 : " + event.getSource()+" , 当前线程 : "+Thread.currentThread().getName());
    }
	// 保证执行顺序 , 多个 ConfigEventListener就需要实现这个接口
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
	
    // 初始化以后要做什么 ? 
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("初始化当前ConfigEventListener");
    }
}
```

#### 5 . ConfigServer - 配置中心服务

```java
@Service
public class ConfigServer {
	
    // 注入applicationContext,因为只有他才可以执行发布事件
    @Autowired
    private ApplicationContext applicationContext;

	// 这个是开启异步 ,后面会说到
    // @Async
    public void publishConfig(){
        // 需要发布 --- > 改变的事件
         System.out.println("发布事件成功 , 当前线程 : "+Thread.currentThread().getName());
        applicationContext.publishEvent(getChange());
    }
    
    
    public ConfigEvent getChange(){
        Config config = new Config();
        config.setNamespace("application");
        HashMap<String, Object> conf = new HashMap<>();
        conf.put("server.port", 8088);
        config.setInfo(conf);
        return  new ConfigEvent(config);
    }
}
```

#### 6. 启动测试

```java
@SpringBootApplication
public class SpringListenerApplication implements CommandLineRunner {

	public static void main(String[] args) {
		SpringApplication.run(SpringListenerApplication.class, args);
	}

	@Autowired
	private ConfigServer server;

	@Override
	public void run(String... args) throws Exception {
		server.publishConfig();
	}
}
```

输出结果 : 

```java
.....
初始化当前ConfigEventListener
.... 
发布事件成功 , 当前线程 : main
接收到更新信息 : Config(namespace=application, info={server.port=8088}) , 当前线程 : main
```

所以一个`Spring-Boot`的事件监听还是很简单的  ,类比到 `Spring`一个道理,相信懂得人都知道 . 但是又一个问题是我们的 发布和监听都是 main线程 ,不好吧 ,玩意有很多事件了 ? 

### 4. 开启异步发布

需要两个注解 `@EnableAsync`启动Async功能 , 和 `@Async`某个方法使用异步执行

```java
发布事件成功 , 当前线程 : SimpleAsyncTaskExecutor-1
接收到更新信息 : Config(namespace=application, info={server.port=8088}) , 当前线程 : SimpleAsyncTaskExecutor-1
```

我们发现就出现了线程池执行 , 这个理的线程池 ,是可以进行配置的 , 只需要我们显式的注入下面这个`SimpleAsyncTaskExecutor` Bean 就可以了

```java
@Bean
public SimpleAsyncTaskExecutor simpleAsyncTaskExecutor() {
    SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor();
    // 需要传入一个 ThreadFactory实现类 , 所以看过我前面写的文章应该会写这个,比如 JUC- Executor那节
    executor.setThreadFactory(new MyThreadFactory("anthony"));
    return executor;
}
```

输出结果 :

```java
发布事件成功 , 当前线程 : anthony-1
接收到更新信息 : Config(namespace=application, info={server.port=8088}) , 当前线程 : anthony-1
```



### 5 . 多个监听器顺序执行 

你可以跟我一样选择实现 `ApplicationListener`和`Ordered` ,或者你可以直接实现 `SmartApplicationListener`都一样的哈,没有哪个好哪个不好

监听器 一 : 

```java
@Component
public class ConfigEventListenerStart implements ApplicationListener<ConfigEvent> , Ordered, InitializingBean {

    @Override
    public void onApplicationEvent(ConfigEvent event) {
        System.out.println("ConfigEventListenerStart 接收到更新信息 : " + event.getSource()+" , 当前线程 : "+Thread.currentThread().getName());
    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }


    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("初始化当前监听器 : " + this.toString());
    }
}
```

监听器 二 : 

```java
@Component
public class ConfigEventListenerEnd implements ApplicationListener<ConfigEvent> , Ordered, InitializingBean {

    @Override
    public void onApplicationEvent(ConfigEvent event) {
        System.out.println("ConfigEventListenerEnd  接收到更新信息 : " + event.getSource()+" , 当前线程 : "+Thread.currentThread().getName());
    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE-1;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("初始化当前监听器 : " + this.toString());
    }
}
```

输出结果 : 

```java
初始化当前监听器 : com.example.springlistener.listener.ConfigEventListenerEnd@6b54655f
初始化当前监听器 : com.example.springlistener.listener.ConfigEventListenerStart@665e9289
..... 
发布事件成功 , 当前线程 : anthony-1
ConfigEventListenerStart 接收到更新信息 : Config(namespace=application, info={server.port=8088}) , 当前线程 : anthony-1
ConfigEventListenerEnd  接收到更新信息 : Config(namespace=application, info={server.port=8088}) , 当前线程 : anthony-1    
```

