# 事务

对于redis这种内存型数据库， 一般是用作分布式缓存的。 但是缓存他会有一定的使用问题。 

## redis - mysql 如何保证一致性

场景 ： redis缓存出现与mysql数据库缓存不一致的现象。 

我们通常处理是 ， 先更新数据， 再删除缓存。 其他顺序出现的问题自己脑补。

一、 查找操作： 

1、 查找redis中存在这个key有没有

2、 没有， 就去数据库中读取，最后写入redis中，记住最好再查询一次，别直接返回，保证确实插入进去了。

二、 更新、删除操作 （这里必须做最后再删除缓存，不做更新操作，如果不是这么做的话，会出现一系列问题）

1、更新，删除数据库数据

2、commit，同时删除redis中的key（这里不考虑删除失败的现象，考虑可以加入重试机制）

以上这种处理方式， 对于单机来说一般适用， 同时也适合并发更新操作，极少情况下出现不一致问题，概率极低。

三、 **但是上诉的执行流程中，我们会发现一个问题， 加入AB两个线程， A线程查询， B线程更新， A线程发现此时key消失了， 此时查询发现数据为100元， 此时B线程更新导致数据修改为0元， 此时删除数据库缓存 ， 此时A线程准备将缓存设置为100， 此时发生不一致的现象， 这种出现的原因是 出现缓存失效和更新操作并发执行的现象。**



四、 那么假如我们出现了数据库读写分离的场景 ， 

比如说 ： A线程确实更新了数据库（写数据库），同时也把缓存删除， 此时B线程来了，他去查询数据库（读数据库） ， 此时B线程读取到未被更新的数据（因为主从复制需要消耗一段时间）， 

如何解决 ？ 

对于这种现象是最难处理的， 因为加入了三个人， 上面单机版是两个人， 那么如何处理三者的事务呢。 

有些人说 ， 使用消息队列，就是将更新操作放入消息队列中， 但是这会填一个洞，挖一个洞，不可靠

我也不知道解决方案， 再不添加中间件的情况下，解决这个问题。





## 如何解决消息队列+业务 的事务问题

> ​	如何保证 业务执行+消息发送的原子性。 



比如你创建订单成功（比如说数据库中创建） -> 发送消息 ->后期业务处理 ， 那么如何保证订单创建成功 与 发送消息这俩原子性呢。 



第一种

1、insert order 

2、send msg-> success

3、commit

比如发送消息成功了， 但是down机了， 没commit掉。

 



第二种

1、insert order 

3、commit

2、send msg-> success（重试）

比如， commit成功了， 但是发送的时候down机了， 添加了订单，但是没发送消息



以上就是问题所在 如何保证这俩属于同一个事物。 



rocket-mq 加入了事物机制。 

基本原理是 ： 

![](https://tyut.oss-accelerate.aliyuncs.com/image/2020-30-33/b6625fad-62ae-4ef9-a665-dd440d77442e.png?x-oss-process=style/template01)

其实我们看这个 1-7流程。 

第一步就是发送消息，这时候处于半消息状态（也就是消息订阅方，无法消费） ， 当我们数据库中处理完成后，commit消息， 如果此时我们down机了， **没事rocket-mq会定期发送一个 检查机制，确认是否发送。**

其实基本就是一个这样的逻辑